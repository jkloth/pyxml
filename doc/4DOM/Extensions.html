<HTML>
  <HEAD>
    <TITLE>4DOM Extensions</TITLE>
    <META charset='UTF-8' HTTP-EQUIV='content-type' CONTENT='text/html'>
    <STYLE TYPE='text/css'>      <!--
      BODY        {background: white}
      A:LINK      {font-weight: 600;
                   font-family: sans-serif;
                   color: blue;
                   text-decoration: none}
      A:VISITED   {font-weight: 600;
                   font-family: sans-serif;
                   color: #800080;
                   text-decoration: none}
      A:ACTIVE    {font-weight: 600;
                   font-family: sans-serif;
                   color: #FF0000;
                   text-decoration: none}
      A:HOVER     {font-weight: 600;
                   font-family: sans-serif;
                   color: #FF0000;
                   text-decoration: none}
    -->

    </STYLE>

  </HEAD>

  <BODY>
    <H1>4DOM Extensions</H1>
    <BR>

<P>
These are utility classes and functions that provide capabilities not yet specified in the DOM spec. Some of these facilities, such as factories and readers are expected to be specified in later levels of the DOM, so we try to keep our proprietary interfaces simple for now so that you can more painlessly migrate when relevant standards emerge.
</P>

<P>
See the demo directory for examples exercising many of these extensions.
</P>


<H3>Reading</H3>

<P>
The Reader package allows you to parse source strings in XML and HTML into DOM trees.  You select a reader module according to the nature of your input.  If you are using Python's htmllib library to read in HTML, use reader.HtmlLib.  If you are reading the xml-sig's SAX package to read in XML, you would use reader.Sax2.  In some cases, you might want to use reader.Sax instead.
</P>

<DIV bgcolor='#66FF66'>
      <A NAME='.xml.dom.ext.reader.Sax2.FromXml'></A>
      <H4>xml.dom.ext.reader.Sax2.FromXml</H4>
      <PRE>xml.dom.ext.reader.Sax2.FromXml(str, ownerDocument, validate, keepAllWs, catName, saxHandlerClass)</PRE>
      <BLOCKQUOTE>
        <P></P>
        <B>Parameters</B>
        <DL>
          <DT>
            <CODE>str</CODE>
                of type
                <I>well-formed XML string</I>
            <BR>
          </DT>

          <DD>
            <P>The XML source</P>
          </DD>

          <DT>
            <CODE>ownerDocument</CODE>
                of type
                <I>xml.dom.Document</I>
            <BR>
          </DT>

          <DD>
            <P>An optional document to hold the generated nodes.  If None, a new document node will be created as the root node.  Default is None.</P>
          </DD>

          <DT>
            <CODE>validate</CODE>
                of type
                <I>boolean</I>
            <BR>
          </DT>

          <DD>
            <P>Whether or not to validate the document.  Default is 0.</P>
          </DD>

          <DT>
            <CODE>keepAllWs</CODE>
                of type
                <I>boolean</I>
            <BR>
          </DT>

          <DD>
            <P>Whether or not to maintain ignorable whitespace in the DOM tree as text nodes. Note that even if you set this flag, you can always get rid of the white space using xml.dom.ext.StripXml().  Default is 0.</P>
          </DD>

          <DT>
            <CODE>catName</CODE>
                of type
                <I>string representing a file path</I>
            <BR>
          </DT>

          <DD>
            <P>An XCatalog file to use for looking up XML public identifiers.  A catalog is only useful if you choose to validate.  Default is None.</P>
          </DD>

          <DT>
            <CODE>saxHandlerClass</CODE>
                of type
                <I>xml.sax.Handler</I>
            <BR>
          </DT>

          <DD>
            <P>SAX event consumer that builds a DOM tree accordingly .  Default is xml.dom.ext.reader.Sax2.XmlDomGenerator.</P>
          </DD>

        </DL>

        <B>Return Value</B>
        <DL>
          <DT>
            <I>xml.dom.Document</I>
          </DT>

          <DD>
            <P>The DOM tree resulting from the given text</P>
          </DD>

        </DL>

      </BLOCKQUOTE>

    </DIV>

    <BR>
    <HR>

<P>There are also similar functions for reading from stream, file name and URL.</P>

<DIV bgcolor='#66FF66'>
      <A NAME='.xml.dom.ext.reader.HtmlLib.FromHtml'></A>
      <H4>xml.dom.ext.reader.HtmlLib.FromHtml</H4>
      <PRE>xml.dom.ext.reader.HtmlLib.FromHtml(str, ownerDocument)</PRE>
      <BLOCKQUOTE>
        <P></P>
        <B>Parameters</B>
        <DL>
          <DT>
            <CODE>str</CODE>
                of type
                <I>HTML string</I>
            <BR>
          </DT>

          <DD>
            <P>The HTML source</P>
          </DD>

          <DT>
            <CODE>ownerDocument</CODE>
                of type
                <I>xml.dom.Document</I>
            <BR>
          </DT>

          <DD>
            <P>An optional document to hold the generated nodes.  If None, a new document node will be created as the root node.  Default is None.</P>
          </DD>

        </DL>

        <B>Return Value</B>
        <DL>
          <DT>
            <I>xml.dom.html.HTMLDocument</I>
          </DT>

          <DD>
            <P>The DOM tree resulting from the given text</P>
          </DD>

        </DL>

      </BLOCKQUOTE>

    </DIV>

    <BR>
    <HR>

<P>There are also similar functions for reading from stream, file name and URL.</P>





<H3>Printing/Writing</H3>

<P>The Printer module allows you to write a text representation of DOM nodes
to an output stream, including stdout. Note that limitations in the
SAX interface used to parse in XML files, and in the DOM spec itself make
it impossible at this point to handle an unchanged "round trip".
That is, if you use the builder to build a DOM node from text and then
use the Printer to turn it back to text, there may be differences;
some may be significant.
</P>

<P>The easiest way to use the Printer module is through the front-end functions in the Ft.Dom.Ext package.</P>

<DIV bgcolor='#66FF66'>
      <A NAME='.xml.dom.ext.Print'></A>
      <H4>xml.dom.ext.Print</H4>
      <PRE>xml.dom.ext.Print(root, stream, encoding)</PRE>
      <BLOCKQUOTE>
        <P>Render the DOM tree to text with no special formatting.</P>
        <B>Parameters</B>
        <DL>
          <DT>
            <CODE>root</CODE>
                of type
                <I>xml.dom.Node.Node</I>
            <BR>
          </DT>

          <DD>
            <P>The node to be printed, with all its children recursively.</P>
          </DD>

          <DT>
            <CODE>stream</CODE>
                of type
                <I>output stream</I>
            <BR>
          </DT>

          <DD>
            <P>An optional document to hold the generated nodes.  The output stream. Note: can be a StringIO object if you want to generate a string instead.  Default is sys.stdout.</P>
          </DD>

          <DT>
            <CODE>encoding</CODE>
                of type
                <I>string</I>
            <BR>
          </DT>

          <DD>
            <P>The character encoding to use for output.  Default is 'UTF-8'.</P>
          </DD>

        </DL>

        <B>Return Value</B>
        <BLOCKQUOTE>
              None
            </BLOCKQUOTE>
      </BLOCKQUOTE>

    </DIV>

    <BR>
    <HR>

<DIV bgcolor='#66FF66'>
      <A NAME='.xml.dom.ext.PrettyPrint'></A>
      <H4>xml.dom.ext.PrettyPrint</H4>
      <PRE>xml.dom.ext.PrettyPrint(root, stream, encoding, indent, width, preserveElements)</PRE>
      <BLOCKQUOTE>
        <P>Render the DOM tree to text, with added indentation and new-lines for enhanced readability.</P>
        <B>Parameters</B>
        <DL>
          <DT>
            <CODE>root</CODE>
                of type
                <I>xml.dom.Node.Node</I>
            <BR>
          </DT>

          <DD>
            <P>The node to be pretty-printed, with all its children recursively.</P>
          </DD>

          <DT>
            <CODE>stream</CODE>
                of type
                <I>output stream</I>
            <BR>
          </DT>

          <DD>
            <P>An optional document to hold the generated nodes.  The output stream. Note: can be a StringIO object if you want to generate a string instead.  Default is sys.stdout.</P>
          </DD>

          <DT>
            <CODE>encoding</CODE>
                of type
                <I>string</I>
            <BR>
          </DT>

          <DD>
            <P>The character encoding to use for output.  Default is 'UTF-8'.</P>
          </DD>

          <DT>
            <CODE>indent</CODE>
                of type
                <I>string</I>
            <BR>
          </DT>

          <DD>
            <P>The amount by which nested constructs are indented when printed on a fresh line.  Default is '\t'.</P>
          </DD>

          <DT>
            <CODE>width</CODE>
                of type
                <I>positive integer</I>
            <BR>
          </DT>

          <DD>
            <P>The width of the output console. Used to make
line-break decisions.  Default is 80.</P>
          </DD>

          <DT>
            <CODE>preserveElements</CODE>
                of type
                <I>list of strings, each of which is an SGML generic identifier.</I>
            <BR>
          </DT>

          <DD>
            <P>Specifes elements in which white-space shouldn't be added.  Note that white-space is never added to in-line elements in an HTMLDocument.  Default is None.</P>
          </DD>

        </DL>

        <B>Return Value</B>
        <BLOCKQUOTE>
              None
            </BLOCKQUOTE>
      </BLOCKQUOTE>

    </DIV>

    <BR>
    <HR>




<H3>Miscellaneous</H3>

<DIV bgcolor='#66FF66'>
      <A NAME='.xml.dom.ext.NodeTypeToInterface'></A>
      <H4>xml.dom.ext.NodeTypeToInterface</H4>
      <PRE>xml.dom.ext.NodeTypeToInterface(nodeType)</PRE>
      <BLOCKQUOTE>
        <P>Look up a node type (as returned from getNodeType()) and returns a corresponding interface name.</P>
        <B>Parameters</B>
        <DL>
          <DT>
            <CODE>nodeType</CODE>
                of type
                <I>One of the integers defined as node types in xml.dom.Node.Node</I>
            <BR>
          </DT>

          <DD>
            <P>The node type to look up.</P>
          </DD>

        </DL>

        <B>Return Value</B>
        <DL>
          <DT>
            <I>string</I>
          </DT>

          <DD>
            <P>Name of corresponding DOM interface from spec.</P>
          </DD>

        </DL>

      </BLOCKQUOTE>

    </DIV>

    <BR>
    <HR>

<DIV bgcolor='#66FF66'>
      <A NAME='.xml.dom.ext.ReleaseNode'></A>
      <H4>xml.dom.ext.ReleaseNode</H4>
      <PRE>xml.dom.ext.ReleaseNode(node)</PRE>
      <BLOCKQUOTE>
        <P>Reclaims a Node from the DOM tree by cutting all links from parent to child and thus eliminating circular references.</P>
        <B>Parameters</B>
        <DL>
          <DT>
            <CODE>node</CODE>
                of type
                <I>xml.dom.Node.Node</I>
            <BR>
          </DT>

          <DD>
            <P>Node to reclaim</P>
          </DD>

        </DL>

        <B>Return Value</B>
        <BLOCKQUOTE>
              None
            </BLOCKQUOTE>
      </BLOCKQUOTE>

    </DIV>

    <BR>
    <HR>

<DIV bgcolor='#66FF66'>
      <A NAME='.xml.dom.ext.StripHtml'></A>
      <H4>xml.dom.ext.StripHtml</H4>
      <PRE>xml.dom.ext.StripHtml(startNode, preserveElements)</PRE>
      <BLOCKQUOTE>
        <P>Strips extraneous white-space from an HTML DOM tree.</P>
        <B>Parameters</B>
        <DL>
          <DT>
            <CODE>startNode</CODE>
                of type
                <I>xml.dom.Node.Node</I>
            <BR>
          </DT>

          <DD>
            <P>The node to be stripped, with all its children recursively.</P>
          </DD>

          <DT>
            <CODE>preserveElements</CODE>
                of type
                <I>list of strings, each of which is an SGML generic identifier, or None to indicate an empty list.</I>
            <BR>
          </DT>

          <DD>
            <P>Specifes elements from which white-space shouldn't be stripped.  Note that white-space is never stripped from in-line elements in an HTMLDocument.  Default is None.</P>
          </DD>

        </DL>

        <B>Return Value</B>
        <DL>
          <DT>
            <I>xml.dom.Node</I>
          </DT>

          <DD>
            <P>The startNode with descendant ignorable white-space stripped.</P>
          </DD>

        </DL>

      </BLOCKQUOTE>

    </DIV>

    <BR>
    <HR>

<DIV bgcolor='#66FF66'>
      <A NAME='.xml.dom.ext.StripXml'></A>
      <H4>xml.dom.ext.StripXml</H4>
      <PRE>xml.dom.ext.StripXml(startNode, preserveElements)</PRE>
      <BLOCKQUOTE>
        <P>Strips extraneous white-space from an XML DOM tree.  Takes xml:space attributes into account.</P>
        <B>Parameters</B>
        <DL>
          <DT>
            <CODE>startNode</CODE>
                of type
                <I>xml.dom.Node.Node</I>
            <BR>
          </DT>

          <DD>
            <P>The node to be stripped, with all its children recursively.</P>
          </DD>

          <DT>
            <CODE>preserveElements</CODE>
                of type
                <I>list of strings, each of which is an SGML generic identifier, or None to indicate an empty list.</I>
            <BR>
          </DT>

          <DD>
            <P>Specifes elements from which white-space shouldn't be stripped.  Default is None.</P>
          </DD>

        </DL>

        <B>Return Value</B>
        <DL>
          <DT>
            <I>xml.dom.Node</I>
          </DT>

          <DD>
            <P>The startNode with descendant ignorable white-space stripped.</P>
          </DD>

        </DL>

      </BLOCKQUOTE>

    </DIV>

    <BR>
    <HR>

<DIV bgcolor='#66FF66'>
      <A NAME='.xml.dom.ext.GetElementById'></A>
      <H4>xml.dom.ext.GetElementById</H4>
      <PRE>xml.dom.ext.GetElementById(startNode, targetId)</PRE>
      <BLOCKQUOTE>
        <P>Returns the element node whose "ID" attribute is as given.</P>
        <B>Parameters</B>
        <DL>
          <DT>
            <CODE>startNode</CODE>
                of type
                <I>xml.dom.Node.Node</I>
            <BR>
          </DT>

          <DD>
            <P>The node whose descendants are to be searched.</P>
          </DD>

          <DT>
            <CODE>targetId</CODE>
                of type
                <I>string conforming to XML ID type</I>
            <BR>
          </DT>

          <DD>
            <P>The XML ID to find.</P>
          </DD>

        </DL>

        <B>Return Value</B>
        <DL>
          <DT>
            <I>xml.dom.Element</I>
          </DT>

          <DD>
            <P>The elemtn with the given ID, or None to indicate no match.</P>
          </DD>

        </DL>

      </BLOCKQUOTE>

    </DIV>

    <BR>
    <HR>

<DIV bgcolor='#66FF66'>
      <A NAME='.xml.dom.ext.GetAllNs'></A>
      <H4>xml.dom.ext.GetAllNs</H4>
      <PRE>xml.dom.ext.GetAllNs(node)</PRE>
      <BLOCKQUOTE>
        <P>Returns all the namespaces in effect on the given node, including the default namespace and the xml namespace.</P>
        <B>Parameters</B>
        <DL>
          <DT>
            <CODE>node</CODE>
                of type
                <I>xml.dom.Node.Node</I>
            <BR>
          </DT>

          <DD>
            <P>The node for which all in-scope namespaces are returned.</P>
          </DD>

        </DL>

        <B>Return Value</B>
        <DL>
          <DT>
            <I>doctionary</I>
          </DT>

          <DD>
            <P>Dictionary mapping all in-scope namespaces to URIs, with '' as prefix for the default namespace.</P>
          </DD>

        </DL>

      </BLOCKQUOTE>

    </DIV>

    <BR>
    <HR>

<DIV bgcolor='#66FF66'>
      <A NAME='.xml.dom.ext.XmlSpaceState'></A>
      <H4>xml.dom.ext.XmlSpaceState</H4>
      <PRE>xml.dom.ext.XmlSpaceState(node)</PRE>
      <BLOCKQUOTE>
        <P>Determines whether the xml:space state at a given node is "preserve" or "default" (See the XML 1.0 spec).</P>
        <B>Parameters</B>
        <DL>
          <DT>
            <CODE>node</CODE>
                of type
                <I>xml.dom.Node.Node</I>
            <BR>
          </DT>

          <DD>
            <P>The node whose space state is to be found.</P>
          </DD>

        </DL>

        <B>Return Value</B>
        <DL>
          <DT>
            <I>string</I>
          </DT>

          <DD>
            <P>"preserve" or "default".</P>
          </DD>

        </DL>

      </BLOCKQUOTE>

    </DIV>

    <BR>
    <HR>

<DIV bgcolor='#66FF66'>
      <A NAME='.xml.dom.ext.SplitQName'></A>
      <H4>xml.dom.ext.SplitQName</H4>
      <PRE>xml.dom.ext.SplitQName(qname)</PRE>
      <BLOCKQUOTE>
        <P>Splits a valid QName from the XML Namespaces 1.0 spec into prefix and suffix (the local name in the case of element and attribute names, and the declared prefix in the case of namespace declarations.</P>
        <B>Parameters</B>
        <DL>
          <DT>
            <CODE>qname</CODE>
                of type
                <I>string matching QName production in XML Namespaces 1.0 spec</I>
            <BR>
          </DT>

          <DD>
            <P>The name to be split.</P>
          </DD>

        </DL>

        <B>Return Value</B>
        <DL>
          <DT>
            <I>tuple with 2 items.</I>
          </DT>

          <DD>
            <P>a tuple of the form (prefix, suffix).  If there is exactly one colon in the qname, prefix is the part before and suffix the part after the colon.  Otherwise prefix is '' and suffix is the entire input string.</P>
          </DD>

        </DL>

      </BLOCKQUOTE>

    </DIV>

    <BR>
    <HR>



</BODY>
</HTML>

